import { StyleSheet, Text, useWindowDimensions, View } from "react-native";
import { Gesture, GestureDetector } from "react-native-gesture-handler";
import Animated, {
  Easing,
  runOnJS,
  useAnimatedStyle,
  useSharedValue,
  withDelay,
  withSequence,
  withSpring,
  withTiming,
} from "react-native-reanimated";

import DeleteButton from "./delete-button";
import ItemQuantity from "./item-quantity";
import { ItemData } from "@/data";

type Props = ItemData & {
  onDelete(): void;
  onQuantityChange(quantity: number): void;
};

const CartItem = ({
  image,
  title,
  price,
  quantity,
  onDelete,
  onQuantityChange,
}: Props) => {
  const containerTranslateX = useSharedValue(0);
  const imageTranslateX = useSharedValue(0);
  const quantityTranslateX = useSharedValue(0);
  const titleTranslateX = useSharedValue(0);
  const otherComponentScale = useSharedValue(1);
  const pinScale = useSharedValue(0);

  const { width: SCREEN_WIDTH } = useWindowDimensions();
  const SPACE = (SCREEN_WIDTH - 316) / 2; // 316 = it's the total size of the components with padding I want to know the size of the empty space generated by justify content to apply the transtalteX
  const MAX_SWIPE = 100;

  const panGestureEvent = Gesture.Pan()
    .onChange((event) => {
      if (event.translationX > 0 && event.translationX < MAX_SWIPE) {
        containerTranslateX.value = event.translationX;
      }
    })
    .onEnd((event) => {
      if (event.translationX < MAX_SWIPE) {
        containerTranslateX.value = withSpring(0);
        imageTranslateX.value = withSpring(0);
        quantityTranslateX.value = withSpring(0);
        titleTranslateX.value = withSpring(0);
        otherComponentScale.value = withSpring(1);
      } else {
        // the numbers used are obtained by calculating the width of the component and the length after applying the scale to position the component correctly in the bin
        imageTranslateX.value = withSpring(
          SCREEN_WIDTH - (containerTranslateX.value + 64)
        );
        quantityTranslateX.value = withSpring(
          SPACE + 60 - containerTranslateX.value
        );
        titleTranslateX.value = withSpring(
          2 * SPACE + 165 - containerTranslateX.value
        );
        otherComponentScale.value = withSequence(
          withTiming(0.4),
          withDelay(500, withTiming(0))
        );
        pinScale.value = withSequence(
          withTiming(1),
          withDelay(
            500,
            withTiming(0, {}, () => runOnJS(onDelete)())
          )
        );
      }
    });

  const rContainerStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateX: containerTranslateX.value,
        },
      ],
    };
  });

  const rImageStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateX: imageTranslateX.value,
        },
        {
          scale: otherComponentScale.value,
        },
      ],
    };
  });

  const rQuantityStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateX: quantityTranslateX.value,
        },
        {
          scale: otherComponentScale.value,
        },
      ],
    };
  });

  const rTitleStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateX: titleTranslateX.value,
        },
        {
          scale: otherComponentScale.value,
        },
      ],
    };
  });

  const rPinStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          scaleY: pinScale.value,
        },
      ],
    };
  });

  const handleDelete = () => {
    // the numbers used are obtained by calculating the width of the component and the length after applying the scale to position the component correctly in the bin
    imageTranslateX.value = withSpring(SCREEN_WIDTH - 64);
    quantityTranslateX.value = withSpring(SPACE + 60);
    titleTranslateX.value = withSpring(2 * SPACE + 165);
    otherComponentScale.value = withSequence(
      withTiming(0.4),
      withDelay(500, withTiming(0))
    );
    pinScale.value = withSequence(
      withTiming(1),
      withDelay(
        500,
        withTiming(0, {}, () => runOnJS(onDelete)())
      )
    );
  };

  return (
    <GestureDetector gesture={panGestureEvent}>
      <View>
        <Animated.View style={[styles.container, rContainerStyle]}>
          <View style={styles.imageContainer}>
            <Animated.Image
              source={{ uri: image }}
              style={[styles.image, rImageStyle]}
            />
            <Animated.View style={[rTitleStyle, styles.titleContainer]}>
              <Text style={styles.title}>{title}</Text>
              <Text style={styles.description}>{`$ ${price * quantity}`}</Text>
            </Animated.View>
          </View>
          <Animated.View style={rQuantityStyle}>
            <ItemQuantity
              quantity={quantity}
              onQuantityChange={onQuantityChange}
            />
          </Animated.View>
          <DeleteButton onDelete={handleDelete} />
        </Animated.View>
        <Animated.View style={[styles.bin, rPinStyle]} />
      </View>
    </GestureDetector>
  );
};

export default CartItem;

const styles = StyleSheet.create({
  container: {
    padding: 16,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
  },
  imageContainer: {
    flexDirection: "row",
    alignItems: "center",
  },
  image: {
    width: 48,
    height: 48,
    marginRight: 16,
  },
  titleContainer: {
    width: 100,
  },
  title: {
    color: "#0c0c0c",
    fontWeight: "bold",
  },
  description: {
    color: "#6e6969",
  },
  bin: {
    zIndex: -1,
    width: 52,
    height: 80,
    backgroundColor: "#960018",
    position: "absolute",
    right: 0,
    top: 0,
  },
});
